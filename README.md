# Projet IA_Embarquee

**Participants:**  
Caio Vinícius Rodrigues Nobre  
Murilo Mattos Muller

**Institution:**  
École Nationale Supérieure des Mines de Saint-Étienne (EMSE-ISMIN)  

---

## Folder structure

  - *Communication_STM32*: contains the python script (“*com.py*”) to test communication with the STM32 board and displays the accuracy (in the terminal). The folder also contains the inputs used, as well as an example of the output that can be viewed in the terminal (“*test_acccuracy*”).
  - *MNIST*: network used to learn how to use cubeMX/IDE, provided by the professor at ecampus.
  - *Machine_Failure*: analysis and validation of the project in cubeIDE with the google colab “*TP_IA_EMBARQUEE*” completed.
  - *Notebook*: contains the google colab file of the trained “*AI4I 2020 Predictive Maintenance Dataset*” model.
  - *ReportCubeMX*: contains the files generated by cubeMX after analysis and validation of the programmed model.
  - *archives_from_colab*: contains the files generated in google colab (“*model_test.h5*”, “*X_test_labels.npy*” and “*Y_test_labels.npy*”) that will be used for analysis and validation in CubeMX. 
---

## Part 1 – Model development on Google Colab



## Part 2 - CubeMX/IDE development

### Objective

Analyze and validate the “*AI4I 2020 Predictive Maintenance Dataset*” model trained on Google Colab in CubeMX, as well as program UART communication on the STM32L4R9AI development board in CubeIDE. Finally, test the communication with a python script, in VsCode, that returns the accuracy of the model embedded on the board.

### Steps taken

1. **Use of CubeMX**
   - Configuration of the "*X-CUBE-AI*" in the categorie of "*Middleware and Software Packs*";
   - Selection of the core in the “*Artificial Intelligence X-CUBE-AI*” tab and the “*Application Template*” in the “*Device Application*” tab;
   - After, going to the “*X-CUBE-AI*” settings, we added a new network called Machine_Failures. Then, using the “*Keras*” model, we select the files generated by the colab: “*model_test.h5*” by clicking browse to load it and “*X_test_labels.npy*” and “*Y_test_labels.npy*” for Validation Inputs and Validation outputs, respectively;
   - Now that the files have been uploaded, we analyze and validate them on the desktop (in this sequence), thus obtaining a good response from the model as can be seen in the files from the ReportCubeMX folder;
   - Finally, go to the “*Project Manager*” tab to configure and start programming a project in CubeIDE.
2. **Use of CubeIDE**
   - Configuration of the “*main.c*” as instructed by the professor, commenting out a few lines in the “* Initialize all configured peripherals *” section:
       ```C
       /* Initialize all configured peripherals */
       MX_GPIO_Init();
       MX_FMC_Init();
       MX_I2C1_Init();
       MX_SAI1_Init();
       //MX_SDMMC1_SD_Init();
       MX_SPI2_Init();
       MX_USART2_UART_Init();
       MX_USART3_UART_Init();
       //MX_USB_OTG_FS_PCD_Init();
       MX_X_CUBE_AI_Init();
       
   -  After that, the “*app_x-cube-ai.c*” file was configured as instructed by the ecampus files. However, specific modifications were made to ensure correct communication with the python script. The functions:
     ```C
     int acquire_and_process_data(ai_i8* data[])
     int post_process(ai_i8* data[])
     ```
  They have been changed to:
   ```C
     int acquire_and_process_data(uint8_t* data)
     int post_process(uint8_t* data)
   ```
  And the looping structure:
  ```C
    do {
    res = acquire_and_process_data(in_data);
    if (res == 0)
        res = ai_run();
    if (res == 0)
        res = post_process(out_data);
    } while (res == 0);
   ```  
  It was changed to:

  ```C
    while (1) {
    res = acquire_and_process_data(in_data);
    if (res != 0) continue;

    res = ai_run();
    if (res != 0) continue;

    res = post_process(out_data);
    if (res != 0) continue;
    }
   ```  
3. **Use of VsCode for python script**
   - For the python script, we used the same one provided by ecampus, changing only the directory of the file for the training tests provided by our model. The only change was:
   ```python
    if __name__ == '__main__':
        X_test = np.load(r"D:\EMSE\IA EMBARQUEE\RepositorioRemoto\IA_Embarquee\Communication_STM32\X_test_labels.npy")
        Y_test = np.load(r"D:\EMSE\IA EMBARQUEE\RepositorioRemoto\IA_Embarquee\Communication_STM32\Y_test_labels.npy")
    
    print(X_test.shape)
    print(Y_test.shape)

   ```
   - The results obtained were satisfactory, even though they still contain many examples of the “No failure” type. An example of the terminal output has been saved in the file “*test_accuracy.txt*”. 
  


